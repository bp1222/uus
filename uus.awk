#!/usr/bin/awk -f

########################################################
# uus.awk                                              #
# Unmaned Update Script (UUS)                          #
#                                                      #
# Usage: sh ./uus.sh <oldimage> <newimage> [ -v [ # ]] #
#                                                      #
# This script when run by the overhead bash script     #
# will check two filesystem images for differences     #
# in a few different areas.  On completion it will     #
# output a PARAM file with the list of changes, and    #
# a tar.bz2 containing the changes.                    #
#                                                      #
# @author David Walker (azrail@csh.rit.edu)            #
#                                                      #
# Version 1.0                                          #
########################################################


#
# Debug Settings
# Setting a higher debug setting will
# print settings below too.
#
# 1 - Print output of what is to be added, deleted, modified, and scripts
# 2 - Print information from file checks between systems
# 3 - Print file parsing information, as to basic information.
# 4 - Print everything that happens


#
# The begin section will run only one time, and is the first
# part of code to run when the script it run.
#
BEGIN {
	##################
	# Global Defines #
	##################

	# isOldImg
	# Tells us if we are currently parsing over the old or
	# new image.
	isOldImg = -1;

	# hashProg
	# Just a define to the program type.
	hashProg = "md5sum";

	# oListing
	# Multi-dimentional array containing values and keys
	# for all the files we are to check in the old filesystem.
	# READ APPENDIX B for why this is needed
	delete oListing;

	# nListing
	# Multi-dimentional array containing values and keys
	# for all the files we are to check in the new filesystem.
	# READ APPENDIX B for why this is needed
	delete nListing;

	# hlinks
	# Array counting the number of times we have seen a given
	# inode, thus checking to see if we have hard links or not.
	# This is a per-image array and will be deleted as such.
	delete hlinks;

	# seen
	# This array will keep track of files we have seen while
	# parsing.  This will allow us to check against the new
	# filesystem quickly by ignoring files we have already seen.
	delete seen;

	# Color Codes
	# The following values, are a ASCII escape code for a specified color.
	c_red = "[1;31;40m";
	c_green = "[1;32;40m";
	c_yellow = "[1;33;40m";
	c_blue = "[1;34;40m";
	c_magenta = "[1;35;40m";
	c_cyan = "[0;36;40m";
	c_white = "[0;37;40m";
	c_bwhite = "[1;37;40m";
	c_reset = "[0m";

	# Print the script header.
	print c_red"+----------------------------------+"c_white;
	print c_red"| Diskimage bundle package builder |"c_white;
	print c_red"+----------------------------------+"c_white;
	print ;
	print c_bwhite"Parsing"c_white" filesystem for updates";

}

#
# This is the main body of the script.
# This section will be run for every input this awk script recieves.
#

{
	# First, we need to see if we even have to check this file.
	# Files to be ignored are:
	# Lines generated by `ls` (eg.  total)
	# . and ..
	# Blank Lines
	if ($0 ~ /^total/ || $0 ~ /\.\.$/ || $0 ~ /\.$/ || $0 == "")
	{
		# Debug Statement
		if (dbg >= 4)
		{
			print "";
			print "Ignoring Line: (it may be blank)"$0;
			print "";
		}
		next;
	}

	# Now that we have a file to check, we can call our asciiBar
	# The purpose of the bar is just to let the user know we are
	# actually still processing data.    
	asciiBar();

	# Debug Statement
	if (dbg >= 3)
	{
		print "\n$$$$----NEW RECORD----$$$$";
		print $0;
	}

	# Split our ls -alR output into the ls array
	split($0, ls, " ");

	# See if the record is a directory
	if ($0 ~ /^\//)
	{
		# Debug Statement
		if (dbg >= 3)
		{
			print "!! Record is a Directory";
		}

		# The following 2 variables represent:
		# cdir = Current Directory in relation to the host system
		# rdir = Relitive Directory with respect to the target system
		#
		# We do this as a simple way to have access the file via THIS 
		# system, or in respect to the images filesystem.
		# 
		# NOTE: They are set to the same here, rdir will change later
		cdir = substr($0, 0, length($0)-1);
		rdir = substr($0, 0, length($0)-1);

		# Debug Statement
		if (dbg >= 3)
		{
			print "CDIR: "cdir;
		}

		# The input here looks as such:
		#
		# /some/path:
		#
		# We split the input on / to get access to the 3rd section.
		# Below is reason for wanting the 3rd and not 2nd.
		#
		# initial: /some/path:
		# split ("/some/path:", outputArray, "/")
		#
		# Split will do this: " " / "some" / "path"
		# outputArray[1] = " "
		# outputArray[2] = "some"
		# outputArray[3] = "path"
		split ($0, imgDir, "/");

		# Check for both "oldmnt" or "oldmnt:" depending if it's the
		# first oldmnt we see it may have the trailing :
		if (imgDir[3] == "oldmnt" || imgDir[3] == "oldmnt:")
		{
			# Are we currently working with the old image (if isOldImg
			# is not equal to 1)
			if (isOldImg != 1)
			{
				# Set the Output Return Separator to ^H or backspace
				ORS="";
				print ""; # Clears the line
				# Reset the Output Return Separator to newline (default)
				ORS="\n"
				print "\n"c_cyan"Clearing Cache..."c_reset;

				# Set that we are working in the old image now
				isOldImg = 1;

				# Reset per-image arrays
				delete oListing;
			}
		}
		# Check for both "newmnt" or "newmnt:" same as before, we can't
		# be sure it will have or not have the trailing :
		else if (imgDir[3] == "newmnt" || imgDir[3] == "newmnt:")
		{
			# Check to see if we are currently working with the new
			# image (if isOldImg is not 0 ... read: isOldImg is false)
			if (isOldImg != 0)
			{
				# Set the Output Return Separator to ^H or backspace
				ORS="";
				print ""; # Clears the line
				# Reset the Output Return Separator to newline (default)
				ORS="\n"
				print "\n"c_cyan"Clearing Cache..."c_reset;

				# Set that we are working in the new image now
				isOldImg = 0;

				# Reset per-image arrays
				delete nListing;
			}
		}

		# The following substitution will make the relitive path of the
		# directory.
		#
		# The RegEx is dependant on the new and old mount directories being
		# EXACTLY one directory from root.  EG:  /tmp/newmnt
		# If that changes the expression below will have to respect that change
		#	
		# The RegEx:
		# Begins with a / followed by any number of characters not a /
		# followed by a / followed by any number of characters not a /
		# followed by a /.  Then replace it with just a /.
		sub(/^\/[^\/]*\/[^\/]*/, "", rdir);

		# Because 'root' level folders output are:
		# /tmp/newmnt
		# Instead of subfolders being:
		# /tmp/newmnt/sub
		# 
		# The above expression will have subfolders being:
		# /sub
		# and 'root' folders being:
		# ""  (or nothing)
		# So we need to set rdir to be '/'
		if (rdir == "")
		{
			rdir = "/";
		}

		# Debug Statement
		if (dbg >= 3)
		{
			print "RDIR: "rdir;
		}

		# We need not check this further, on to the next record
		next;
	}

	# The file name will change depending on how ls reports.  For Symbolic
	# links ls givs us:
	#
	# ...   filename -> /path/to/real
	#
	# So for a normal file the last record in the ls array would be the
	# file, but for a sym link, it is the last record - 2.
	if (ls[2] ~ /^l/)
		fname = ls[length(ls)-2];
	else
		fname = ls[length(ls)];

	# Set the path with respect to the target image
	if (rdir == "/")
		path = rdir fname;
	else 
		path = rdir"/"fname;

	# We don't need to handle SOME kinds of files.  The Linux Kernel
	# has files in /proc and /sys that are dynamic to the kernel.  Udev
	# or devfs (or like) are used to manage nodes in /dev.  So we need not
	# check files contained in said locations.
	if (path ~ /^\/dev\// || path ~ /^\/sys\// || path ~ /^\/proc\//)
	{
		# Debug Statement
		if (dbg >= 3)
		{
			print "Ignoring file handled by Linux Kernel"
		}
		next;
	}

	# Debug Statement
	if (dbg >= 3)
	{
		print "PATH: "path;
	}

	# Are we in the new or old image
	if (isOldImg == 1)
	{
		# Set this path in the old listing, so we know we've seen it.
		oListing[path] = path;
	}
	else
	{
		# Set this path in the new listing, so we know we've seen it.
		nListing[path] = path;
	}

	############################
	# Start Major File Parsing #
	############################

	# If the output from ls starts with d checking a directory
	# Record looks like:
	# drwxr-xr-x  root....
	if (ls[2] ~ /^d/)
	{
		# We need to know if we're in the old or new image.
		if (isOldImg)
		{
			# Set basic info, type, group, owner
			oListing[path, "type"] = "dir";
			oListing[path, "owner"] = ls[4];
			oListing[path, "group"] = ls[5];
		}
		else
		{
			# Set basic info, type, group, owner
			nListing[path, "type"] = "dir";
			nListing[path, "owner"] = ls[4];
			nListing[path, "group"] = ls[5];
		}

		# Get permissions
		getPerms(path);
	}
	# If the record begins with l, or symbolic link
	# Record looks like:
	# lrwxrwxrwx  root ...
	else if (ls[2] ~ /^l/)
	{
		if (dbg >= 3)
		{
			print "!! Record is a LINK";
		}
		# Check to see if this is a hard link before other processing.
		findHardLinks(path, ls[3], ls[1]);

		# Store where this link points to.
		link = ls[length(ls)];

		# If the link begins with / we know that it is a absolute path
		# to the real file.  We process as such.
		if (link ~ /^\//)
		{
			# This constructs the command we will use to re-link
			# this file.
			#
			# Remember rdir does not have a leading or tailing slash to it.
			cmd = "ln -fs "link" "rdir"/"fname" 2> /dev/null";
		}
		else
		{
			# This constructs the command we will use to re-link
			# this file.
			cmd = "ln -fs "rdir"/"link" "rdir"/"fname" 2> /dev/null";
		}

		# Are we in the new or old image
		if (isOldImg)
		{
			oListing[path, "type"] = "sym";
			oListing[path, "link"] = cmd;
		}
		else
		{
			nListing[path, "type"] = "sym";
			nListing[path, "link"] = cmd
		}
	}
	# If the record begins with -, or regular file (can be different types)
	else if (ls[2] ~ /^-/)
	{
		# Check to see if this is a hard link before any processing
		findHardLinks(path, ls[3], ls[1]);

		# Current type, may change as we examine this file.
		cType = "flat";

		# Get Permissions
		getPerms(path);

		# See if the file is executable
		if (ls[2] ~ /^...x/ || ls[2] ~ /^......x/ || ls[2] ~ /^.........x/)
		{
			# Reset the current type to exe
			cType = "exe";
		}

		####################################################################
		# ALL flat file types will be hashed as a FIRST round of checking. #
		####################################################################

		# Command to generate hash.
		# cdir is the directory location with relation to the HOST machine
		cmd = hashProg" "cdir"/"fname;

		# Run the command.
		cmd | getline hashOut;

		# Close the command. (Keep our file pointers clean)
		close(cmd);

		# The command generates the following output:
		# <hash number>  <filename>
		# So we need to split it, and get the first element.
		split(hashOut, hashArr, " ");
		hash = hashArr[1];

		# Are we in the new or old image
		if (isOldImg)
		{
			oListing[path, "type"] = cType;
			oListing[path, "owner"] = ls[4];
			oListing[path, "group"] = ls[5];
			oListing[path, "hash"] = hash;
		}
		else
		{
			nListing[path, "type"] = cType;
			nListing[path, "owner"] = ls[4];
			nListing[path, "group"] = ls[5];
			nListing[path, "hash"] = hash;
		}
	}
	# If the record begins with a c or b, meaning character or block device
	else if (ls[2] ~ /^c/ || ls[2] ~ /^b/)
	{
		# Check to see if this is a hard link before any processing
		findHardLinks(path, ls[3], ls[1]);

		# We need to get the major and minor version number for the
		# device node.  This is found within the ls output
		# To check the major number, we need to cut out the last , from
		# ls[5].  ls[6] is good for the minor number.
		major = substr(ls[6], 0, length(ls[6]-1));
		minor = ls[7];

		# Are we in the new or old image
		if (isOldImg)
		{
			oListing[path, "type"] = "chbl";
			oListing[path, "cbmaj"] = major;
			oListing[path, "cbmin"] = minor;
		}
		else
		{
			nListing[path, "type"] = "chbl";
			nListing[path, "cbmaj"] = major;
			nListing[path, "cbmin"] = minor;
		}
		################################
		# Place to add new file checks #
		################################
	}
} # End Main Loop

#
# The end section will only run one time and it will occour after the main
# loop has no more input.
#
# By this point we have looped over both file systems and have their data
# stored in our arrays.  Now all that's left to do is check to see what's
# different.
#

END {
	print "";
	print "[1;37;40mChecking for Modifications[0m";

	# For each 'i' in oListing.
	# Read this as: foreach (key in array)
	for (i in oListing)
	{
		# Split i into fields to get the real key.  Why, read the next comment
		split(i, field, SUBSEP);

		# See if this real key has already been seen, if it has we can ignore
		# it and continue.  Else, we mark it as seen, and continue on.
		#
		# READ APPENDIX A FOR REASON WHY THIS IS HERE
		if (field[1] in seen)
			continue;
		else
			seen[field[1]] = field[1];

		# Degug Statement
		if (dbg >= 2)
		{
			print "----------------<>----------------";
			print "Filename is: "field[1];
			print "";
		}

		# Check to see if this file is in the new listing.  If it is
		# we do nothing, however if it is not, we delete it.
		if (i in nListing)
		{
			if (0);
			# Do Nothing
		}
		else
		{
			if (dbg >= 2)
			{
				print "<--DELETE--";
				print "File: "field[1];
				print "<----------";
				print "----------------<>----------------";
			}

			# Is this file to be deleted a directory
			if (oListing[field[1], "type"] == "dir")
			{
				cmd = "rm -fR "field[1];
				rBefore[cmd] = cmd;
				continue;
			}

			# Not a directory, rather a file, so we delete normally.
			del[field[1]] = field[1];
			continue;
		}

		############################
		# Begin major file chcking #
		############################

		# Switch on the file type.  We process each type differently
		switch (oListing[field[1], "type"])
		{
			# To be checked is a directory.
			case /dir/:
			# See if the type is the same
			if (!checkType(field[1]))
			{
				continue;
			}
			# Check to see if the permission owner or group has changed.
			if (!checkPOG(field[1]))
			{
				continue;
			}
			break;

			# Type is a flat file.
			case /flat/:
			# Check the type of the file
			if (!checkType(field[1]))
			{
				continue;
			}

			# See if the hashes match
			if (oListing[field[1], "hash"] == nListing[field[1], "hash"])
			{
				# Hashes are ok, check permission/group/owner, if different
				if (!checkPOG(field[1]))
				{
					continue;
				}
			}
			# Hashes are different, mark to update.
			else
			{
				# Debug Statement
				if (dbg)
				{
					print "--UPDATE--";
					print "--FLAT-HASH--";
					print "Name: "field[1];
					print "-----";
					print "----------------<>----------------";
				}

				upd[field[1]] = field[1];
				continue;
			}
			break;

			# Type is a symbolic link
			case /sym/:
			# Check types, if they are different
			if (!checkType(field[1]))
			{
				continue;
			}

			# Check to see if the link has changed
			if (oListing[field[1], "link"] == nListing[field[1], "link"])
			{
				if (0);
				# Link is the same, do nothing
			}
			else
			{
				# Debug output.
				if (dbg)
				{
					print "--CMD--";
					print "--SYM-LINK--";
					print "Type: "nListing[field[1], "type"];
					print "Name: "field[1];
					print "------\n"
					print "----------------<>----------------";
				}

				# Mark to add this file.
				# Just relink the file.
				cmd = nListing[field[1], "link"];
				rAfter[cmd] = cmd;
				continue;
			}
			break;

			# Type is exe
			case /exe/:
			# Check types, if they are different
			if (!checkType(field[1]))
			{
				continue;
			}

			# See if hashes match
			if (oListing[field[1], "hash"] == nListing[field[1], "hash"])
			{
				# Hashes match, check POG
				if (!checkPOG(field[1]))
				{
					continue;
				}
			}
			# Hashes do not match
			else
			{
				# If is a shared object, or kernel object.
				if (field[1] ~ /\.so/ || field[1] ~ /\.ko/)
				{
					# Check POG    
					if (!checkPOG(field[1]))
					{
						continue;
					}

					# We exclude these from version checking because
					# they can not be run that way.  If run like:
					# ./path/kernelobject it may cause a SegFault.
					# so we can just avoid it.
					continue;
				}

				if (field[1] ~ /cgi$/)
				{
					# Mark to update
					upd[field[1]] = field[1];
					continue;
				}

				# First we need to check to see if this file has a --version option.

				cmd = oldmnt field[1]" --version 2>&1 /dev/null; echo $?";
				cmd | getline outp;
				close(cmd);

				# Error on getting the version.
				if (outp != 0)
				{
					# Mark to update
					upd[field[1]] = field[1];
					continue;
				}
				else
				{
					# Check Old EXE versions
					cmd = oldmnt field[1]" --version 2>&1 /dev/null";
					# Run the cmd
					cmd | getline outp;
					# Keep our filepointers clean!
					close(cmd)
					oldv = outp;

					# Check New EXE version
					cmd = newmnt field[1]" --version 2>&1 /dev/null";
					# Run the cmd
					cmd | getline outp;
					# Keep our filepointers clean!
					close(cmd)
					newv = outp;

					# See if Versions are different, if so, update
					if (newv == oldv)
					{
						# They are not, check POG
						if (!checkPOG(field[1]))
						{							
							continue;
						}
					}
					# Versions are different
					else
					{
						# Debug Statement
						if (dbg)
						{
							print "--UPDATE--";
							print "--EXE-VERSION--";
							print "NLIST: "nListing[field[1], "type"];
							print "FIELD: "field[1];
							print "-----";
							print "----------------<>----------------";
						}

						# Mark to update
						upd[field[1]] = field[1];
						continue;
					}
				}
			}
			break;

			# Type is character or block device
			case /chbl/:
			# Check types, if they are different
			if (!checkType(field[1]))
			{
				continue;
			}

			# See if the versions match.
			if (oListing[field[1], "cbmaj"] == nListing[field[1], "cbmaj"] && oListing[field[1], "cbmin"] == nListing[field[1], "cbmin"])
			{
				# They are not, check POG
				if(!checkPOG(field[1]))
				{
					continue;
				}
			}
			else
			{
				# Debug Statement
				if (dbg)
				{
					print "--UPDATE--";
					print "--CHBL-VERS--";
					print "OMajor: "oListing[field[1],"cbmaj"];
					print "OMinor: "oListing[field[1],"cbmin"];
					print "NMajor: "nListing[field[1],"cbmaj"];
					print "NMinor: "nListing[field[1],"cbmin"];
					print "-----";
					print "----------------<>----------------";
				}

				# Mark to update
				upd[field[1]] = field[1];
				continue;
			}
			break;

			################################
			# Place to add new type checks #
			################################

			default:
			# do nothing
			if (dbg)
			{
				print "We're not fileist, we just don't like your type";
			}
			break;
		}
	}

	for (i in nListing)
	{
		# Split the ls -alR output into an array
		split(i, field, SUBSEP);

		# Read Appendix A for why the following code exists.

		# If we have seen this path
		if (field[1] in seen)
		{
			# If we have seen this file, BUT is being deleted
			# we should re-add it.
			if (field[1] in del)
			{
				# So remember Appendix A?  Why do we need to add this file
				# now, even though it's set to delete?  Simple.  Remember
				# that with AWK when we use the multi-dimentional arrays we get:
				# /some/path/fileminorKey
				# Well, when we do that check to see if i is in nListing above
				# the type may have changed and another minorKey is used.  One
				# not seen in nListing, where field[1] is in nListing (with another
				# minorKey)
				#
				# So in short, this file really is in the new image, so let's add it.
				seen[field[1]] = 1;
			}
			else
			{
				continue;
			}
		}
		else
		{
			# Add to the list of what we have seen
			seen[field[1]] = 1;
		}

		# Debug Statement
		if (dbg >= 2)
		{
			print "--ADD-->";
			print "--NEW--";
			print "Name: "field[1];
			print "Type: "nListing[field[1], "type"];
			print "----->";
			print "----------------<>----------------";
		}

		# If the new file is a symlink
		if (nListing[field[1], "type"] == "sym")
		{
			# Get the command to run and add it to runafter
			cmd = nListing[field[1], "link"];
			rAfter[cmd] = cmd;
			continue;
		}

		if (nListing[field[1], "type"] == "dir")
		{
			# If the new object is a Directory, make a command to 
			# delete what may be on the filesystem with that path.
			cmd = "mkdir -p "field[1];
			rBefore[cmd] = cmd;
			continue;
		}

		# Not seen yet, set to add this file.
		add[field[1]] = field[1];
	}

	# Make the temporary holding folder
	bundleFolder = "./bundle";

	cmd = "mkdir "bundleFolder;

	# Run the command
	cmd | getline outp;

	# Keep our filepointers clean!
	close(cmd);

	# Output default, standard, lines to our special files
	print "[1D" > bundleFolder"/PARAM";
	print "#!/bin/bash" > bundleFolder"/runbefore.sh";
	print "#!/bin/bash" > bundleFolder"/runafter.sh";

	# Debug Statement
	if (dbg)
	{
		print "\nGoing to delete:";
	}
	# Loop through each object in the delete array
	for (i in del)
	{
		# Output the file to the PARAM list
		print "delete "del[i] >> bundleFolder"/PARAM";

		# Debug Statement
		if (dbg)
		{
			print del[i];
		}
	}

	# Debug Statement
	if (dbg)
	{
		print "\nGoing to update:";
	}
	# Loop through each object in the update array
	for (i in upd)
	{
		# Output the file to the PARAM list
		print upd[i] >> bundleFolder"/PARAM";

		# Add this file to the update bundle
		addFile(i, bundleFolder);

		# Debug Statement
		if (dbg)
		{
			print upd[i];
		}
	}

	# Debug Statement
	if (dbg)
	{
		print "\nGoing to add:";
	}
	# Loop through each object in the add array
	for (i in add)
	{
		# Output the file to the PARAM list
		print add[i] >> bundleFolder"/PARAM";

		# Add this file to the update bundle
		addFile(i, bundleFolder);

		# Debug Statement
		if (dbg)
		{
			print add[i];
		}
	}

	# Debug Statement
	if (dbg)
	{
		print "\nRun Before Script will contain:";
	}
	# Loop through each object in the runBefore array
	for (i in rBefore)
	{
		# Add this command to the runbefore script
		print rBefore[i] >> bundleFolder"/runbefore.sh";

		# Debug Statement
		if (dbg)
		{
			print rBefore[i];
		}
	}

	# Debug Statement
	if (dbg) 
	{
		print "\nRun After Script will contain:";
	}
	# Loop through each object in the runAfter array
	for (i in rAfter)
	{
		# Add this command to the runafter script
		print rAfter[i] >> bundleFolder"/runafter.sh";

		# Debug Statement
		if (dbg)
		{
			print rAfter[i];
		}
	}
	print "Update Bundle is finished.  It can be found in the";
	print "bundle folder, within this one.  Any warnings above";
	print "about broken pipes are ok.  Those files will just be";
	print "updated within this build."
}


#####################
# Defined Functions #
#####################

#
# !!!NOTE!!!
#
# A standard function convention used is to have an '_' (underscore) character
# as a prefix to all function scope variables.  This is a prevention as to
# not overwrite any variables used from where the function was called.
# This is because AWK's scope is for the script, not function.
#

#
# asciiBar
#
# This function just handles the update of the ascii art on the
# screen to alert the user that we are still running, and have
# not crashed.
#
# ANSI ASCII Symbols used in the function:
# <esc> => ^[  escape character, alerting ascii codes
#
# <esc>[X;XX;XXm =>  This code is for color
#                 - The first X is for special Features 0=default
#                 - The second 2 X's are for foreground color
#                 - The last 2 X's are for background color
#                 - The 'm' is the special ASCII character meaning color code
#
# <esc>[XD => Code is for movement.
#           - The first X is how many characters to jump
#           - The D means Left.  There are other end codes for up,down,right
#
# Look at the following website for more information on ANSI ASCII codes.
# http://www.delmar.edu/Courses/CIS415L/ANSIsys.htm
#
function asciiBar()
{
	# Update the bar every 2 itterations
	if (_cnt == 2)
	{
		# Reset the Output Return Seperator to
		ORS="[9D";

		# Depending on what itteration, print that line and incliment
		# pointer variable
		if (_ccnt == 0)
		{
			print " "c_reset"["c_red"*"c_green"*"c_yellow"*"
			c_blue"*"c_magenta"*"c_cyan"*"c_reset"]";
			_ccnt = 1;
		}
		else if (_ccnt == 1)
		{
			print " "c_reset"["c_cyan"*"c_red"*"c_green"*"
			c_yellow"*"c_blue"*"c_magenta"*"c_reset"]";
			_ccnt = 2;
		}
		else if (_ccnt == 2)
		{
			print " "c_reset"["c_magenta"*"c_cyan"*"c_red"*"
			c_green"*"c_yellow"*"c_blue"*"c_reset"]";
			_ccnt = 3;
		}
		else if (_ccnt == 3)
		{
			print " "c_reset"["c_blue"*"c_magenta"*"c_cyan"*"
			c_red"*"c_green"*"c_yellow"*"c_reset"]";
			_ccnt = 4;
		}
		else if (_ccnt == 4)
		{
			print " "c_reset"["c_yellow"*"c_blue"*"c_magenta"*"
			c_cyan"*"c_red"*"c_green"*"c_reset"]";
			_ccnt = 5;
		}
		else if (_ccnt == 5)
		{
			print " "c_reset"["c_green"*"c_yellow"*"c_blue"*"
			c_magenta"*"c_cyan"*"c_red"*"c_reset"]";
			_ccnt = 0;
		}

		# Reset counter
		_cnt = 0;

		# Reset the Output Return Separator to newline (default)
		ORS="\n";
	}
	else
	{
		# Increment our counter.
		_cnt++;
	}
}

#
# addFile
#
# This function will take a parameter being the files name, and add
# the file to our temporary directory.  The files moved are ones that
# need to be updated, or added.  Files are copied DIRECTLY with no
# modifications to owner, group, or time.
#
# @params fileName - file's name with respect to target
#
function addFile (fileName, bf)
{
	# Init function variables
	_hostPath = newmnt; # Path of the file in respect to host
	_relPath = "";      # Path of the file in respect to target

	# We need to get only the directory that this file exits
	# in, so we split it on the /, and will itterate over it
	# and snarf out the directory path.
	split(fileName, _spFile, "/");

	# Itterate over the splitted filename.
	# /home/something/file
	# - split -
	# . home something file (period represents blank space
	# 1  2      3       4   (position in the array)
	# So we start at 2, and go for the length of the array.
	for (_i=2; _i <= length(_spFile); _i++)
	{
		_hostPath = _hostPath"/"_spFile[_i];

		# This is needed to make the path with respect to the target
		if (_i != length(_spFile))
		{
			_relPath = _relPath"/"_spFile[_i];
		}
	}

	# If the file existed in the '/' directory the relPath would not be
	# set, so we set it to '/' here.
	if (_relPath == "")
	{
		_relPath = "/";
	}

	# Command to make the directory in our temp build directory
	_cmd = "mkdir -p "bf""_relPath;

	# Run the command
	_cmd | getline _outp;

	# Keep our file pointers clean
	close(_cmd);

	# Command to copy the file from image to the temp build directory
	_cmd = "cp -pR "_hostPath" "bf""fileName;

	# Run the command
	_cmd | getline _outp;

	# Keep our file pointers clean
	close(_cmd);
}

#
# checkPOG
#
# Function simply takes the given key and checks
# to see if perm/owner/group are the same.
#
# @param key - Key is the path name, or MainKey of the array
#
# @returns 1 if they are the same
# @returns 0 if they are different
#
function checkPOG(key) 
{
	# Debug statement
	if (dbg >= 3)
	{
		print "-- "key;
		print "OPerm: "oListing[key, "perm"];
		print "NPerm: "nListing[key, "perm"];
		print "OOWner: "oListing[key, "owner"];
		print "NOwner: "nListing[key, "owner"];
		print "OGroup: "oListing[key, "group"];
		print "NGroup: "nListing[key, "group"];
		print "OType:  "oListing[key, "type"];
		print "NType: "nListing[key, "type"];
		print "--";
	}

	# See if this file is a hard link, and if it needs
	# to be updated by this check.
	if (!checkHardLink(key))
	{
		return 0;
	}

	# Check to see if the perm and owner and group are the same,
	# if they are, return 1, else return 0
	if (oListing[key, "perm"] == nListing[key, "perm"] && oListing[key, "owner"] == nListing[key, "owner"] && oListing[key, "group"] == nListing[key, "group"])
	{
		return 1;
	}
	else
	{
		# Debug Statement
		if (dbg >= 2)
		{
			print "--UPDATE--";
			print "--POG--";
			print "Name: "key;
			print "Type: "oListing[key, "type"];
			print "-----";
			print "----------------<>----------------";
		}

		# Mark to update
		upd[key] = key;
		return 0;
	}
}

#
# checkType
#
# Checks to see if the type of the key in the oListing
# and the type of the nListing are the same.  If they
# are not, we will put into the runbefore.sh script to
# delete the file/directory.
#
# We will set to delete the file that currently resides
# in the image, so we will be able to write over it.
#
# @param key - Key is the path name, or MainKey of the array
#
# @returns 1 if they are the same
# @returns 0 if they are different
#
function checkType(key)
{
	# Check to see if type is the same
	if (oListing[key, "type"] == nListing[key, "type"])
	{
		return 1;
	}
	else
	{
		# Debug Statement
		if (dbg >= 2)
		{
			print "--";
			print "Checking type of " key"\n";
		}

		# Command to put in the runbefore.sh script
		_cmd = "rm -fR "key;

		# Debug Statement
		if (dbg >= 2)
		{
			print "OTYPE: "oListing[key, "type"];
			print "NTYPE: "nListing[key, "type"];
			print "TYPE CHANGE";
			print "Will Delete: "_cmd;
			print "--\n";
			print "--ADD-->";
			print "--"nListing[key, "type"]"--TYPE--";
			print "Name: "key;
			print "------->";
			print "----------------<>----------------";
		}

		# Add to the runbefore array to be outputed later.
		rBefore[_cmd] = _cmd;

		# Mark to add this for real.
		add[key] = key;
		return 0;
	}
}

#
# checkPerms
#
# Function will check to see if the permissions on a file
# have changed then return.
#
# @param key - Key is the path name, or MainKey of the array
#
# @returns 1 - if they are the same
# @returns 0 - if they are different
#
function checkPerms(key)
{
	# Check to see if the perm is the same.
	if (oListing[key, "perm"] == nListing[key, "perm"])
	{
		# Return that they are
		return 1;
	}
	# Permissions have changed
	else
	{
		# See if this file is a hard link, and if it needs
		# to be updated by this check.
		if (!checkHardLink(key))
		{
			return 1;
		}

		# Command to run to change permissions.
		# Formatted as such:
		# chmod -f XXXX /path/to/file
		_cmd = "chmod -f "nListing[key, "perm"]" "key;

		# Add to rAfter array.
		rAfter[cmd] = cmd;

		return 0;
	}
}


#
# getPerms
#
# Gets the passed parameters for the key and stores them
# into the file array.
#
# @param key - Key is the path name, or MainKey of the array
#
function getPerms(key)
{
	# Command to get the numerical permission
	_cmd = "stat "cdir"/"fname" | head -4 | tail +4";

	# Run the command
	_cmd | getline _outp;

	# Keep our file pointers clean!
	close(_cmd);

	# Split on a " ", the 2nd value of the new array will
	# have the numerical permission value in it
	split(_outp, _firstPermVal, " ");

	# 2nd spot has the permission, but we have to split
	# again to get the first part of the permission value.
	split(_firstPermVal[2], _permVal, "/");

	# We are now left with (XXXX where XXXX is the numerical
	# value of the permission.  We substr starting at char
	# 2 to get rid of the leading (
	_perms = substr(_permVal[1], 2);

	# Debug statement
	if (dbg >= 3)
	{
		print "Perms: "_perms;
		print "CurrentDir: "cdir;
		print "CurrentFile: "fname;
	}

	# We need to know if we're in the old or new image
	if (isOldImg == 1)
	{
		oListing[key, "perm"] = _perms;
	}
	else
	{
		nListing[key, "perm"] = _perms;
	}
}

#
# findHardLinks
#
# Simply, this function checks if a file (passed key) has
# any hard links with it, if it does it makes note and will
# handle it with the hlinks array, and not mark it for
# inclusion in the main file array
#
# This does not see if the inode on the two images have changed
# because we could care less about that.
#
# @param key - Key is the path name, or MainKey of the array
# @param links - Number of hard links the file has.  Saves time
#                 instead of getting the information through stat
#
function findHardLinks(key, links, inode)
{
	# If the last thing in the _fields array is > 1, means we have
	# more than one link to the file.  So there is a hard link somewhere
	if (links > 1)
	{
		# If we see this inode in the hlinks array
		if (inode in hlinks)
		{
			# Incriment count of links to this file
			hlinks[inode]++;
		}
		else
		{
			# Set this as a hard link.
			hlinks[inode] = 1;
		}

		# Are we working on the old or new image
		if (isOldImg)
		{
			# Set the file's inode
			oListing[key, "inode"] = inode;
		}
		else
		{
			# Set the file's inode
			nListing[key, "inode"] = inode;
		}
	}
}

#
# checkHardLink
#
# This function will check to see if a file needs to be updated.
# Files will not be updated if their hard link has already been
# updated, this is to prevent the same file being changed many times
# and losing the direct link to the file.
#
# @returns 1 - if hard link has reported upgrade already
# @returns 0 - if there has not been an update yet
#
function checkHardLink(key)
{
	_cinode = oListing[key, "inode"];

	# See if the key is recorded as a hard link
	if (_cinode in hlinks)
	{
		# Has this file been sladed for upgrade
		if (hlinks[_cinode] == -1)
		{
			# Return 1, this file has been upgraded
			return 1;
		}
		# File has not yet been seen for upgrade
		else
		{
			# Mark file as upgraded
			hlinks[_cinode] = -1;

			# Return that this file has not been seen for upgrade
			return 0;
		}
	}
	else
	{
		return 0;
	}
}


##############
# Appendix A #
##############
############################################################################
#
# Ok, so why do we have the for (i in oListing), and then split it and check
# for the 'real key'.  Well the answer is in how AWK does multi-dimentional
# arrays.  It more or less is a clever hack job to make them work.  I will
# explain now:
#
# Multi-dimensional arrays are used like the following:
#    multArray["mainKey", "subKey"]     = value;
#    multArray["mainKey", "anotherSub"] = newValue;
#
# No tricks there, when ever you print out multArray["mainKey","subKey"]
# you do in fact get value.  But how does it know that.  Well AWK really
# only has support for single key arrays.  So what it does in the background
# is it makes the real key, mainKey\034subKey where \034 is octal for a
# non printable character.
#
# So taking the above multArray lets show what happens in a normal use.
#
# for (i in multArray) {
#    print i;
# }
#
# Output:
# mainKeysubKey
# mainKeyanotherSub
#
# And that is not what we want.  So AWK has a variable defined as \034
# for this purpose.  It is called SUBSEP.  So what we have to do here,
# is split 'i' on SUBSEP so we have access to the real keys we want.
# As shows:
#
# for (i in multArray) {
#    split(i, keyArray, SUBSEP);
#    print "MAIN KEY: "keyArray[1];
#    print "SUB KEY:  "keyArray[2];
# }
#
# Output:
#
# MAIN KEY: mainKey
# SUB KEY:  subKey
# MAIN KEY: mainKey
# SUB KEY:  anotherSub
#
# Since we know that we will handle all the subkeys within our END, we can
# take the mainKey, store it in in a seen array, and if we ever come across
# it again, we can just ignore and continue.
#
############################################################################




#############
# Apendix B #
#############
############################################################################
# So why do we need both oListing and nListing, and split parsing input
# between them.
#
# Well, I initially thought that we would be able to just run through this
# once, and on the second run through we will be going through the new
# filesystem and do the checking then.  HOWEVER, the command we run:
#
# ls -alR /tmp/newmnt /tmp/oldmnt
#
# We do not want to be put into a position that we depend on ls, or the lead
# script, for listing the entire contents of the oldmnt first.  So we split
# all input into the 2 arrays and then will process against them at the end.
# This is probably not the fastest way to do the job, however it gurantees
# that we process the data in the correct mannor, and in doing things right
# we can give up a little bit of time.
############################################################################
